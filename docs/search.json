[
  {
    "objectID": "hw6.html",
    "href": "hw6.html",
    "title": "hw6.qmd",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\nlapply applies a function to each element of a list\npurrr equivalent function is map ()\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = “kendall”) on each element of the list. Write code to do this below! (I’m really trying to ask you how you specify method = “kendall” when calling lapply())\n\n\nlibrary(purrr)\nhelp(\"matrix\")\nnumeric_matrix &lt;- list(matrix(rnorm(25), ncol=5), matrix(rnorm(25), ncol=5))\nlapply_example &lt;- lapply(numeric_matrix, FUN = cor,  method = \"kendall\")\n\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\nautomatic handling of data types and type consistency through the map_* functions\nthe same inconsistent approach to function arguments and implementations in BaseR. Conway’s Law of Anarchy is the best description. They built a system that matched the communication structure of the organization.\n\nWhat is a side-effect function?\n\nA side effect function is a function that represents the underlying data e.g. print\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\nNamespace and scoping. Variables inside of functions are scoped to the local function. This means the variable will only exist during the function runtime. Once the function returns, the sd variable will be deallocated from memory. Since the function sd is a different object in a separately scoped namespace (stats) than the variable sd, R will only look for a more global scope if no locally scoped sd object does not exist.\n\n\n\n\n\n\n\n\ngetRMSE &lt;- function (response, predicted){\n  sqrt(mean((response - predicted)^2))\n}\n\n\n\n\ngetRMSE &lt;- function (response, predicted, ...){\n  sqrt(mean((response - predicted)^2, ...))\n}\n\n\n\n\n\n\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\nrmse_tst &lt;- getRMSE(resp, pred)\nprint(rmse_tst)\n\n[1] 0.9581677\n\n\n\n\n\n\nrando_index_1 &lt;- sample(length(resp),1)\nrando_index_2 &lt;- sample(length(pred),1)\nresp[rando_index_1] &lt;- NA_real_\npred[rando_index_2] &lt;- NA_real_\nrmse_tst &lt;- getRMSE(resp, pred, na.rm = TRUE)\nprint(rmse_tst)\n\n[1] 0.9659906\n\n\n\n\n\n\n# assert na.rm = TRUE returns a number\nrmse_tst &lt;- getRMSE(resp, pred, na.rm = TRUE)\nprint(rmse_tst)\n\n[1] 0.9659906\n\n# assert na.rm = FALSE returns NA\nrmse_tst &lt;- getRMSE(resp, pred, na.rm = FALSE)\nprint(rmse_tst)\n\n[1] NA\n\n\n\n\n\n\n\ngetMAE &lt;- function (response, predicted, ...){\n  mean(abs(response - predicted), ...)\n}\n\n\n\n\n\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\nmae_tst &lt;- getMAE(resp,pred)\nprint(mae_tst)\n\n[1] 0.8155776\n\n\n\n\n\n\nrando_index_1 &lt;- sample(length(resp),1)\nrando_index_2 &lt;- sample(length(pred),1)\nresp[rando_index_1] &lt;- NA_real_\npred[rando_index_2] &lt;- NA_real_\nmae_tst &lt;- getMAE(resp,pred)\nprint(mae_tst)\n\n[1] NA\n\n\n\n\n\n\n# assert na.rm = TRUE returns a number\nmae_tst &lt;- getMAE(resp, pred, na.rm = TRUE)\nprint(mae_tst)\n\n[1] 0.8242225\n\n# assert na.rm = FALSE returns NA\nmae_tst &lt;- getMAE(resp, pred, na.rm = FALSE)\nprint(mae_tst)\n\n[1] NA\n\n\n\n\n\n\n\nsnoop &lt;- function(resp,\n                  pred,\n                  metrics = c(\"rmse\",\"RMSE\",\"getRMSE\",\"mae\",\"MAE\",\"getMAE\"), ...){\n  if (!(is.numeric(resp) & \n        is.vector(resp)  & \n        is.atomic(resp)  &\n        is.numeric(pred) &\n        is.atomic(pred)  &\n        is.vector(pred))){\n    stop(\"Prediction and Response should be numeric vectors\")\n  }\n  # dotdotdot &lt;- names(list(...))\n  # print(dotdotdot)\n  metrics &lt;- tolower(metrics)\n  result &lt;- list(rmse = NULL, mae = NULL)\n  \n  if(is.null(metrics)){\n    result$rmse &lt;- getRMSE(resp, pred, ...)\n    result$mae  &lt;- getMAE(resp, pred, ...)\n  }\n  else {\n    if(\"rmse\" %in% metrics | \"getrmse\" %in% metrics){\n      result$rmse &lt;- getRMSE(resp, pred, ...)\n    }\n    if(\"mae\" %in% metrics | \"getmae\" %in% metrics){\n      result$mae &lt;- getMAE(resp,pred, ...)\n    }\n    return(result)\n  }\n}\n\n\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nrmse_tst &lt;- snoop(resp, pred, \"rmse\")\nmae_tst &lt;- snoop(resp, pred, \"MAE\")\nboth_tst &lt;- snoop(resp, pred)\n\n\n\n\n\nrando_index_1 &lt;- sample(length(resp),1)\nrando_index_2 &lt;- sample(length(pred),1)\nresp[rando_index_1] &lt;- NA_real_\npred[rando_index_2] &lt;- NA_real_\n\nrmse_na_tst &lt;- snoop(resp, pred, \"rmse\", na.rm = TRUE)\nmae_na_tst &lt;- snoop(resp, pred, \"MAE\", na.rm = TRUE)\nboth_na_tst &lt;- snoop(resp, pred,na.rm = TRUE)\n\n\n\n\n\n# df &lt;- data.frame(col1 = 0.1, col2 = 0.2)\n# df_tst &lt;- snoop(resp, df)\n# df_tst &lt;- snoop(df, pred, \"rmse\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nAttaching package: 'jsonlite'\n\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\n\n\n#store key\n# usethis::edit_r_environ()\nreadRenviron(\"~/.Renviron\")\nnews_api_key &lt;- Sys.getenv(\"NEWS_API_KEY\")\n\nquery &lt;- URLencode(\"FEMA+Militia+Chimney Rock\")\nfrom_date &lt;- \"2024-10-01\"\nto_date &lt;- \"2024-10-15\"\nurl &lt;- paste0(\"https://newsapi.org/v2/everything?q=\", query,\n              \"&from=\", from_date,\n              \"&to=\", to_date,\n              \"&sortBy=popularity&apiKey=\", news_api_key)\n\n# print(url)\nnews_info &lt;-GET(url) |&gt;\n  content(\"text\") |&gt;\n  fromJSON(flatten = TRUE, simplifyDataFrame = TRUE) |&gt;\n  pluck(\"articles\")\n\nnews_info &lt;- as.tibble(news_info)\n\nWarning: `as.tibble()` was deprecated in tibble 2.0.0.\nℹ Please use `as_tibble()` instead.\nℹ The signature and semantics have changed, see `?as_tibble`.\n\n\n\n\n\n\nnews_query &lt;- function(subject, start_date, api_key){\n  \n}"
  },
  {
    "objectID": "hw6.html#task-1",
    "href": "hw6.html#task-1",
    "title": "hw6.qmd",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\n\nlapply applies a function to each element of a list\npurrr equivalent function is map ()\n\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = “kendall”) on each element of the list. Write code to do this below! (I’m really trying to ask you how you specify method = “kendall” when calling lapply())\n\n\nlibrary(purrr)\nhelp(\"matrix\")\nnumeric_matrix &lt;- list(matrix(rnorm(25), ncol=5), matrix(rnorm(25), ncol=5))\nlapply_example &lt;- lapply(numeric_matrix, FUN = cor,  method = \"kendall\")\n\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\nautomatic handling of data types and type consistency through the map_* functions\nthe same inconsistent approach to function arguments and implementations in BaseR. Conway’s Law of Anarchy is the best description. They built a system that matched the communication structure of the organization.\n\nWhat is a side-effect function?\n\nA side effect function is a function that represents the underlying data e.g. print\n\nWhy can you name a variable sd in a function and not cause any issues with the sd function?\n\nNamespace and scoping. Variables inside of functions are scoped to the local function. This means the variable will only exist during the function runtime. Once the function returns, the sd variable will be deallocated from memory. Since the function sd is a different object in a separately scoped namespace (stats) than the variable sd, R will only look for a more global scope if no locally scoped sd object does not exist."
  },
  {
    "objectID": "hw6.html#task-2---writing-r-functions",
    "href": "hw6.html#task-2---writing-r-functions",
    "title": "hw6.qmd",
    "section": "",
    "text": "getRMSE &lt;- function (response, predicted){\n  sqrt(mean((response - predicted)^2))\n}\n\n\n\n\ngetRMSE &lt;- function (response, predicted, ...){\n  sqrt(mean((response - predicted)^2, ...))\n}\n\n\n\n\n\n\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\nrmse_tst &lt;- getRMSE(resp, pred)\nprint(rmse_tst)\n\n[1] 0.9581677\n\n\n\n\n\n\nrando_index_1 &lt;- sample(length(resp),1)\nrando_index_2 &lt;- sample(length(pred),1)\nresp[rando_index_1] &lt;- NA_real_\npred[rando_index_2] &lt;- NA_real_\nrmse_tst &lt;- getRMSE(resp, pred, na.rm = TRUE)\nprint(rmse_tst)\n\n[1] 0.9659906\n\n\n\n\n\n\n# assert na.rm = TRUE returns a number\nrmse_tst &lt;- getRMSE(resp, pred, na.rm = TRUE)\nprint(rmse_tst)\n\n[1] 0.9659906\n\n# assert na.rm = FALSE returns NA\nrmse_tst &lt;- getRMSE(resp, pred, na.rm = FALSE)\nprint(rmse_tst)\n\n[1] NA\n\n\n\n\n\n\n\ngetMAE &lt;- function (response, predicted, ...){\n  mean(abs(response - predicted), ...)\n}\n\n\n\n\n\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\nmae_tst &lt;- getMAE(resp,pred)\nprint(mae_tst)\n\n[1] 0.8155776\n\n\n\n\n\n\nrando_index_1 &lt;- sample(length(resp),1)\nrando_index_2 &lt;- sample(length(pred),1)\nresp[rando_index_1] &lt;- NA_real_\npred[rando_index_2] &lt;- NA_real_\nmae_tst &lt;- getMAE(resp,pred)\nprint(mae_tst)\n\n[1] NA\n\n\n\n\n\n\n# assert na.rm = TRUE returns a number\nmae_tst &lt;- getMAE(resp, pred, na.rm = TRUE)\nprint(mae_tst)\n\n[1] 0.8242225\n\n# assert na.rm = FALSE returns NA\nmae_tst &lt;- getMAE(resp, pred, na.rm = FALSE)\nprint(mae_tst)\n\n[1] NA\n\n\n\n\n\n\n\nsnoop &lt;- function(resp,\n                  pred,\n                  metrics = c(\"rmse\",\"RMSE\",\"getRMSE\",\"mae\",\"MAE\",\"getMAE\"), ...){\n  if (!(is.numeric(resp) & \n        is.vector(resp)  & \n        is.atomic(resp)  &\n        is.numeric(pred) &\n        is.atomic(pred)  &\n        is.vector(pred))){\n    stop(\"Prediction and Response should be numeric vectors\")\n  }\n  # dotdotdot &lt;- names(list(...))\n  # print(dotdotdot)\n  metrics &lt;- tolower(metrics)\n  result &lt;- list(rmse = NULL, mae = NULL)\n  \n  if(is.null(metrics)){\n    result$rmse &lt;- getRMSE(resp, pred, ...)\n    result$mae  &lt;- getMAE(resp, pred, ...)\n  }\n  else {\n    if(\"rmse\" %in% metrics | \"getrmse\" %in% metrics){\n      result$rmse &lt;- getRMSE(resp, pred, ...)\n    }\n    if(\"mae\" %in% metrics | \"getmae\" %in% metrics){\n      result$mae &lt;- getMAE(resp,pred, ...)\n    }\n    return(result)\n  }\n}\n\n\n\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nrmse_tst &lt;- snoop(resp, pred, \"rmse\")\nmae_tst &lt;- snoop(resp, pred, \"MAE\")\nboth_tst &lt;- snoop(resp, pred)\n\n\n\n\n\nrando_index_1 &lt;- sample(length(resp),1)\nrando_index_2 &lt;- sample(length(pred),1)\nresp[rando_index_1] &lt;- NA_real_\npred[rando_index_2] &lt;- NA_real_\n\nrmse_na_tst &lt;- snoop(resp, pred, \"rmse\", na.rm = TRUE)\nmae_na_tst &lt;- snoop(resp, pred, \"MAE\", na.rm = TRUE)\nboth_na_tst &lt;- snoop(resp, pred,na.rm = TRUE)\n\n\n\n\n\n# df &lt;- data.frame(col1 = 0.1, col2 = 0.2)\n# df_tst &lt;- snoop(resp, df)\n# df_tst &lt;- snoop(df, pred, \"rmse\")"
  },
  {
    "objectID": "hw6.html#task-3---query-an-api-and-tidy-style-function",
    "href": "hw6.html#task-3---query-an-api-and-tidy-style-function",
    "title": "hw6.qmd",
    "section": "",
    "text": "── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nAttaching package: 'jsonlite'\n\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\n\n\n#store key\n# usethis::edit_r_environ()\nreadRenviron(\"~/.Renviron\")\nnews_api_key &lt;- Sys.getenv(\"NEWS_API_KEY\")\n\nquery &lt;- URLencode(\"FEMA+Militia+Chimney Rock\")\nfrom_date &lt;- \"2024-10-01\"\nto_date &lt;- \"2024-10-15\"\nurl &lt;- paste0(\"https://newsapi.org/v2/everything?q=\", query,\n              \"&from=\", from_date,\n              \"&to=\", to_date,\n              \"&sortBy=popularity&apiKey=\", news_api_key)\n\n# print(url)\nnews_info &lt;-GET(url) |&gt;\n  content(\"text\") |&gt;\n  fromJSON(flatten = TRUE, simplifyDataFrame = TRUE) |&gt;\n  pluck(\"articles\")\n\nnews_info &lt;- as.tibble(news_info)\n\nWarning: `as.tibble()` was deprecated in tibble 2.0.0.\nℹ Please use `as_tibble()` instead.\nℹ The signature and semantics have changed, see `?as_tibble`.\n\n\n\n\n\n\nnews_query &lt;- function(subject, start_date, api_key){\n  \n}"
  }
]